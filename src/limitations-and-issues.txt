Limitations:
 - Wrapper objects for primitive types are not preserved when serializing, eg.: String becomes string (primitive), Number becomes number (primitive).
 - Custom types in nested arrays are not supported when deserializing.
 - When @JsonMember is applied to a getter/setter, even when using reflect-metadata a 'type' setting must be specified or a type-annotation must be added.
 - Does not behave well with multiple frames. Deserialization must be performed in same frame where the object being deserialized is defined.
 - When returning a derived type from a @JsonObject initilizer function, the generic type parameter must be specified to match the decorated class.

Planned features:
 - Preserve object references. Currently, serializing-deserializing an object where multiple properties contain the same instance will yield separate instances.
 - Built-in, seamless compatibility with Json.NET. Json.NET uses fully qualified names for type hinting, which have no meaning in TypeScript.
     Currently, custom initializers must be used to resolve this.

Troubleshooting:
 - "Expected value to be 'x', got 'x'."
     Occurs when using multiple frames: the two 'x' types are not the same objects, because they are not from the same frame.
 - "Argument of type 'typeof *' is not assignable to parameter of type 'new () => any'."
     The referenced class does not contain a parameterless constructor.
     To fix, add a parameterless constructor to the class, or an initializer function to @JsonObject settings.