{"version":3,"sources":["webpack://typedjson/webpack/universalModuleDefinition","webpack://typedjson/webpack/bootstrap","webpack://typedjson/./src/typedjson/helpers.ts","webpack://typedjson/./src/typedjson/metadata.ts","webpack://typedjson/./src/typedjson/deserializer.ts","webpack://typedjson/./src/typedjson/serializer.ts","webpack://typedjson/./src/typedjson/json-object.ts","webpack://typedjson/./src/typedjson/json-member.ts","webpack://typedjson/./src/typedjson/json-array-member.ts","webpack://typedjson/./src/typedjson/json-set-member.ts","webpack://typedjson/./src/typedjson/json-map-member.ts","webpack://typedjson/./src/typedjson.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","METADATA_FIELD_KEY","isObject","parseToJSObject","json","JSON","parse","TypeError","isSubtypeOf","A","B","logError","message","optionalParams","_i","arguments","length","console","error","apply","concat","log","logWarning","warn","isValueDefined","isInstanceOf","constructor","Number","String","Boolean","isReflectMetadataSupported","Reflect","getMetadata","multilineString","values","join","nameof","fn","JsonMemberMetadata","metadata_JsonObjectMetadata","JsonObjectMetadata","dataMembers","Map","knownTypes","Set","getJsonObjectName","ctor","metadata","getFromConstructor","classType","target","targetPrototype","isExplicitlyMarked","getFromInstance","getPrototypeOf","getKnownTypeNameFromType","getKnownTypeNameFromInstance","injectMetadataInformation","propKey","objectMetadata","parentMetadata","decoratorName","deserializer","forEach","_metadata","_propKey","set","writable","add","keyType","elementType","elemCtor","deserializer_Deserializer","Deserializer","_typeResolver","sourceObject","__type","_errorHandler","setNameResolver","nameResolverCallback","_nameResolver","setTypeResolver","typeResolverCallback","setErrorHandler","errorHandlerCallback","convertAsObject","sourceObjectTypeInfo","objectName","_this","expectedSelfType","selfConstructor","sourceObjectMetadata","knownTypeConstructors","_mergeKnownTypes","_createKnownTypesMap","typeFromTypeHint","sourceObjectWithDeserializedProperties_1","memberMetadata","revivedValue","memberValue","memberNameForDebug","expectedMemberType","convertSingleValue","elementConstructor","keyConstructor","key","isRequired","targetObject","initializerCallback","e","_instantiateType","assign","onDeserializedMethodName","targetObject_1","keys","sourceKey","typeInfo","memberName","srcTypeNameForDebug","_isDirectlyDeserializableNativeType","_makeTypeErrorMessage","Date","_throwTypeMismatchError","Float32Array","Array","every","elem","isNaN","Float64Array","Uint8Array","map","Uint8ClampedArray","Uint16Array","Uint32Array","ArrayBuffer","_stringToArrayBuffer","DataView","_stringToDataView","convertAsArray","convertAsSet","convertAsMap","elementTypeInfo","slice","element","resultSet","keyTypeInfo","valueTypeInfo","resultMap","targetType","expectedSourceType","actualSourceType","expectedType","actualType","knownTypeMaps","result","knowTypes","indexOf","convertNativeObject","str","buf","bufView","strLen","charCodeAt","serializer_Serializer","Serializer","_typeHintEmitter","setTypeHintEmitter","typeEmitterCallback","selfType","_isDirectlySerializableNativeType","convertAsArrayBuffer","convertAsDataView","elementTypes","_isTypeTypedArray","convertAsTypedArray","expectedName","actualName","sourceTypeMetadata","serializer","__assign","expectedElementType","expectedTypeName","actualTypeName","typeInfoForElements","resultArray","resultElement","push","expectedKeyType","resultKeyValuePairObj","from","buffer","charCode","fromCharCode","dataView","Int8Array","Int16Array","Int32Array","jsonObject","optionsOrTarget","options","decorator","knownType","isAbstract","initializer","knownTypeMethodName","filter","jsonMember","propCtor","isSpecialPropertyType","emitDefaultValue","toString","reflectPropCtor","jsonArrayMember","dimensions","jsonSetMember","jsonMapMember","valueConstructor","typedjson_TypedJSON","TypedJSON","rootConstructor","settings","globalKnownTypes","indent","rootMetadata","nameResolver","errorHandler","config","_globalConfig","rootType","parseAsArray","parseAsSet","parseAsMap","valueType","stringify","stringifyAsArray","stringifyAsSet","stringifyAsMap","keyCtor","valueCtor","setGlobalConfig","typedjson_assign","replacer","typeResolver","typeHintEmitter","ktc","knownTypeCtor","fill","_mapKnownTypes","serializedObject","elementConstructorArray","constructors"],"mappings":"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","file":"typedjson.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"typedjson\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"typedjson\"] = factory();\n\telse\n\t\troot[\"typedjson\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","declare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport const METADATA_FIELD_KEY = \"__typedJsonJsonObjectMetadataInformation__\";\n\nexport function getDefaultValue<T>(type: { new (): T }): T\n{\n    switch (type as any)\n    {\n        case Number:\n            return 0 as any;\n\n        case String:\n            return \"\" as any;\n\n        case Boolean:\n            return false as any;\n\n        case Array:\n            return [] as any;\n\n        default:\n            return undefined;\n    }\n}\n\nexport function isPrimitiveType(type: any): type is (typeof Number | typeof String | typeof Boolean)\n{\n    return (type === String || type === Boolean || type === Number);\n}\n\nexport function isPrimitiveValue(obj: any)\n{\n    switch (typeof obj)\n    {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n            return true;\n        default:\n            return (obj instanceof String || obj instanceof Number || obj instanceof Boolean);\n    }\n}\n\nexport function isObject(value: any): value is Object\n{\n    return typeof value === \"object\";\n}\n\nexport function parseToJSObject(json: any): Object {\n    if (isObject(json)) {\n        return json;\n    }\n    json = JSON.parse(json);\n    if (!isObject(json)) {\n        throw new TypeError(\"TypedJSON can only parse JSON strings or plain JS objects\");\n    }\n    return json;\n}\n\n/**\n * Determines if 'A' is a sub-type of 'B' (or if 'A' equals 'B').\n * @param A The supposed derived type.\n * @param B The supposed base type.\n */\nexport function isSubtypeOf(A: Function, B: Function)\n{\n    return A === B || A.prototype instanceof B;\n}\n\nexport function logError(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.error === \"function\")\n    {\n        console.error.apply(console, [message].concat(optionalParams));\n    }\n    else if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log.apply(console, [\"ERROR: \" + message].concat(optionalParams));\n    }\n}\n\nexport function logMessage(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log.apply(console, [message].concat(optionalParams));\n    }\n}\n\nexport function logWarning(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.warn === \"function\")\n    {\n        console.warn.apply(console, [message].concat(optionalParams));\n    } else if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log.apply(console, [\"WARNING: \" + message].concat(optionalParams));\n    }\n}\n\n/**\n * Checks if the value is considered defined (not undefined and not null).\n * @param value\n */\nexport function isValueDefined(value: any): boolean\n{\n    return !(typeof value === \"undefined\" || value === null);\n}\n\nexport function isInstanceOf<T>(value: any, constructor: Function): boolean\n{\n    if (typeof value === \"number\")\n    {\n        return (constructor === Number);\n    }\n    else if (typeof value === \"string\")\n    {\n        return (constructor === String);\n    }\n    else if (typeof value === \"boolean\")\n    {\n        return (constructor === Boolean);\n    }\n    else if (isObject(value))\n    {\n        return (value instanceof constructor);\n    }\n\n    return false;\n}\n\nexport const isReflectMetadataSupported = (typeof Reflect === \"object\" && typeof Reflect.getMetadata === \"function\");\n\nexport function multilineString(...values: string[])\n{\n    return values.join(\" \");\n}\n\n/**\n * Gets the name of a function.\n * @param fn The function whose name to get.\n */\nexport function nameof(fn: Function & { name?: string })\n{\n    if (typeof fn.name === \"string\")\n    {\n        return fn.name;\n    }\n    else\n    {\n        return \"undefined\";\n    }\n}\n","import { nameof } from \"./helpers\";\nimport * as Helpers from \"./helpers\";\nimport { IndexedObject } from \"./types\";\n\nexport class JsonMemberMetadata\n{\n    /** If set, a default value will be emitted for uninitialized members. */\n    public emitDefaultValue: boolean;\n\n    /** Member name as it appears in the serialized JSON. */\n    public name: string;\n\n    /** Property or field key of the json member. */\n    public key: string;\n\n    /** Constuctor (type) reference of the member. */\n    public ctor: Function;\n\n    /** If set, indicates that the member must be present when deserializing. */\n    public isRequired: boolean;\n\n    /** If the json member is an array, map or set, sets member options of elements/values. Subsequent values define the types of nested arrays. */\n    public elementType: Function[];\n\n    /** If the json member is a map, sets member options of array keys. */\n    public keyType: Function;\n\n    /** Custom deserializer to use. */\n    public deserializer?: (json: any) => any;\n\n    /** Custom serializer to use. */\n    public serializer?: (value: any) => any;\n}\n\nexport class JsonObjectMetadata\n{\n    //#region Static\n    /**\n     * Gets the name of a class as it appears in a serialized JSON string.\n     * @param ctor The constructor of a class (with or without jsonObject).\n     */\n    public static getJsonObjectName(ctor: Function): string\n    {\n        var metadata = this.getFromConstructor(ctor);\n\n        return metadata ? nameof(metadata.classType) : nameof(ctor);\n    }\n\n    /**\n     * Gets jsonObject metadata information from a class or its prototype.\n     * @param target The target class or prototype.\n     * @param allowInherited Whether to use inherited metadata information from base classes (if own metadata does not exist).\n     */\n    public static getFromConstructor(target: Object | Function): JsonObjectMetadata\n    {\n        var targetPrototype: any;\n        var metadata: JsonObjectMetadata;\n\n        targetPrototype = (typeof target === \"function\") ? target.prototype : target;\n\n        if (!targetPrototype)\n        {\n            return undefined;\n        }\n\n        if (targetPrototype.hasOwnProperty(Helpers.METADATA_FIELD_KEY))\n        {\n            // The class prototype contains own jsonObject metadata.\n            metadata = targetPrototype[Helpers.METADATA_FIELD_KEY];\n        }\n\n        if (metadata && metadata.isExplicitlyMarked) // Ignore implicitly added jsonObject (through jsonMember).\n        {\n            return metadata;\n        }\n        else\n        {\n            return undefined;\n        }\n    }\n\n    /**\n     * Gets jsonObject metadata information from a class instance.\n     * @param target The target instance.\n     */\n    public static getFromInstance(target: any): JsonObjectMetadata\n    {\n        return this.getFromConstructor(Object.getPrototypeOf(target));\n    }\n\n    /**\n     * Gets the known type name of a jsonObject class for type hint.\n     * @param target The target class.\n     */\n    public static getKnownTypeNameFromType(target: Function): string\n    {\n        var metadata = this.getFromConstructor(target);\n        return metadata ? nameof(metadata.classType) : nameof(target);\n    }\n\n    /**\n     * Gets the known type name of a jsonObject instance for type hint.\n     * @param target The target instance.\n     */\n    public static getKnownTypeNameFromInstance(target: any): string\n    {\n        var metadata = this.getFromInstance(target);\n        return metadata ? nameof(metadata.classType) : nameof(target.constructor);\n    }\n    //#endregion\n\n    public dataMembers: Map<string, JsonMemberMetadata> = new Map<string, JsonMemberMetadata>();\n\n    public knownTypes: Set<Function> = new Set<Function>();\n\n    public knownTypeMethodName: string;\n\n    /** Gets or sets the constructor function for the jsonObject. */\n    public classType: Function;\n\n    public isExplicitlyMarked: boolean;\n\n    public isAbstract: boolean;\n\n    public onDeserializedMethodName: string;\n\n    public initializerCallback: (sourceObject: Object, rawSourceObject: Object) => Object;\n\n    public name: string;\n}\n\nexport function injectMetadataInformation(target: IndexedObject, propKey: string | symbol, metadata: JsonMemberMetadata)\n{\n    var decoratorName = `@jsonMember on ${nameof(target.constructor)}.${propKey}`; // For error messages.\n    var objectMetadata: JsonObjectMetadata;\n    var parentMetadata: JsonObjectMetadata;\n\n    // When a property decorator is applied to a static member, 'target' is a constructor function.\n    // See: https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md#property-decorators\n    // ... and static members are not supported here, so abort.\n    if (typeof target === \"function\")\n    {\n        Helpers.logError(`${decoratorName}: cannot use a static property.`);\n        return;\n    }\n\n    // Methods cannot be serialized.\n    if (typeof target[propKey] === \"function\")\n    {\n        Helpers.logError(`${decoratorName}: cannot use a method property.`);\n        return;\n    }\n\n    if (!metadata || (!metadata.ctor && !metadata.deserializer))\n    {\n        Helpers.logError(`${decoratorName}: JsonMemberMetadata has unknown ctor.`);\n        return;\n    }\n\n    // Add jsonObject metadata to 'target' if not yet exists ('target' is the prototype).\n    // NOTE: this will not fire up custom serialization, as 'target' must be explicitly marked with '@jsonObject' as well.\n    if (!target.hasOwnProperty(Helpers.METADATA_FIELD_KEY))\n    {\n        // No *own* metadata, create new.\n        objectMetadata = new JsonObjectMetadata();\n        parentMetadata = target[Helpers.METADATA_FIELD_KEY];\n\n        objectMetadata.name = target.constructor.name; // Default.\n\n        // Inherit @JsonMembers from parent @jsonObject (if any).\n        if (parentMetadata) // && !target.hasOwnProperty(Helpers.METADATA_FIELD_KEY)\n        {\n            parentMetadata.dataMembers.forEach((_metadata, _propKey) => objectMetadata.dataMembers.set(_propKey, _metadata));\n        }\n\n        // ('target' is the prototype of the involved class, metadata information is added to this class prototype).\n        Object.defineProperty(target, Helpers.METADATA_FIELD_KEY, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: objectMetadata\n        });\n    }\n    else\n    {\n        // JsonObjectMetadata already exists on 'target'.\n        objectMetadata = target[Helpers.METADATA_FIELD_KEY];\n    }\n\n    if (!metadata.deserializer)\n        objectMetadata.knownTypes.add(metadata.ctor);\n\n    if (metadata.keyType)\n        objectMetadata.knownTypes.add(metadata.keyType);\n\n    if (metadata.elementType)\n        metadata.elementType.forEach(elemCtor => objectMetadata.knownTypes.add(elemCtor));\n\n    objectMetadata.dataMembers.set(metadata.name, metadata);\n}\n","import { nameof } from \"./helpers\";\nimport * as Helpers from \"./helpers\";\nimport { IndexedObject } from \"./types\";\nimport { JsonObjectMetadata } from \"./metadata\";\n\nexport interface IScopeTypeInfo\n{\n    selfConstructor: Function;\n    elementConstructor?: Function[];\n    keyConstructor?: Function;\n    knownTypes: Map<string, Function>;\n}\n\n/**\n * Utility class, converts a simple/untyped javascript object-tree to a typed object-tree.\n * It is used after parsing a JSON-string.\n */\nexport class Deserializer<T>\n{\n    private _typeResolver: (sourceObject: Object, knownTypes: Map<string, Function>) => Function;\n    private _nameResolver: (ctor: Function) => string;\n    private _errorHandler: (error: Error) => void;\n\n    constructor()\n    {\n        this._typeResolver = (sourceObject: any, knownTypes: Map<string, Function>) =>\n        {\n            if (sourceObject.__type) return knownTypes.get(sourceObject.__type);\n        };\n\n        this._errorHandler = (error) => Helpers.logError(error);\n    }\n\n    public setNameResolver(nameResolverCallback: (ctor: Function) => string)\n    {\n        this._nameResolver = nameResolverCallback;\n    }\n\n    public setTypeResolver(typeResolverCallback: (sourceObject: Object, knownTypes: Map<string, Function>) => Function)\n    {\n        if (typeof typeResolverCallback !== \"function\") throw new TypeError(\"'typeResolverCallback' is not a function.\");\n\n        this._typeResolver = typeResolverCallback;\n    }\n\n    public setErrorHandler(errorHandlerCallback: (error: Error) => void)\n    {\n        if (typeof errorHandlerCallback !== \"function\") throw new TypeError(\"'errorHandlerCallback' is not a function.\");\n\n        this._errorHandler = errorHandlerCallback;\n    }\n\n    public convertAsObject(sourceObject: IndexedObject, sourceObjectTypeInfo: IScopeTypeInfo, objectName = \"object\")\n    {\n        if (typeof sourceObject !== \"object\" || sourceObject === null)\n        {\n            this._errorHandler(new TypeError(`Cannot deserialize ${objectName}: 'sourceObject' must be a defined object.`));\n            return undefined;\n        }\n\n        let expectedSelfType = sourceObjectTypeInfo.selfConstructor;\n        let sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(expectedSelfType);\n        let knownTypeConstructors = sourceObjectTypeInfo.knownTypes;\n\n        if (sourceObjectMetadata)\n        {\n            // Merge known types received from \"above\" with known types defined on the current type.\n            knownTypeConstructors = this._mergeKnownTypes(knownTypeConstructors, this._createKnownTypesMap(sourceObjectMetadata.knownTypes));\n        }\n\n        // Check if a type-hint is available from the source object.\n        let typeFromTypeHint = this._typeResolver(sourceObject, knownTypeConstructors);\n\n        if (typeFromTypeHint)\n        {\n            // Check if type hint is a valid subtype of the expected source type.\n            if (Helpers.isSubtypeOf(typeFromTypeHint, expectedSelfType))\n            {\n                // Hell yes.\n                expectedSelfType = typeFromTypeHint;\n                sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(typeFromTypeHint);\n\n                if (sourceObjectMetadata)\n                {\n                    // Also merge new known types from subtype.\n                    knownTypeConstructors = this._mergeKnownTypes(knownTypeConstructors, this._createKnownTypesMap(sourceObjectMetadata.knownTypes));\n                }\n            }\n        }\n\n        if (sourceObjectMetadata && sourceObjectMetadata.isExplicitlyMarked)\n        {\n            // Strong-typed deserialization available, get to it.\n            // First deserialize properties into a temporary object.\n            let sourceObjectWithDeserializedProperties = {} as IndexedObject;\n\n            // Deserialize by expected properties.\n            sourceObjectMetadata.dataMembers.forEach((memberMetadata, propKey) =>\n            {\n                let memberValue = sourceObject[propKey];\n                let memberNameForDebug = `${nameof(sourceObjectMetadata.classType)}.${propKey}`;\n                let expectedMemberType = memberMetadata.ctor;\n\n                let revivedValue;\n                if (memberMetadata.deserializer) {\n                    revivedValue = memberMetadata.deserializer(memberValue);\n                } else {\n                    revivedValue = this.convertSingleValue(memberValue, {\n                        selfConstructor: expectedMemberType,\n                        elementConstructor: memberMetadata.elementType,\n                        keyConstructor: memberMetadata.keyType,\n                        knownTypes: knownTypeConstructors\n                    }, memberNameForDebug);\n                }\n\n                if (Helpers.isValueDefined(revivedValue))\n                {\n                    sourceObjectWithDeserializedProperties[memberMetadata.key] = revivedValue;\n                }\n                else if (memberMetadata.isRequired)\n                {\n                    this._errorHandler(new TypeError(`Missing required member '${memberNameForDebug}'.`));\n                }\n            });\n\n            // Next, instantiate target object.\n            let targetObject: IndexedObject;\n\n            if (typeof sourceObjectMetadata.initializerCallback === \"function\")\n            {\n                try\n                {\n                    targetObject = sourceObjectMetadata.initializerCallback(sourceObjectWithDeserializedProperties, sourceObject);\n\n                    // Check the validity of user-defined initializer callback.\n                    if (!targetObject)\n                    {\n                        throw new TypeError(Helpers.multilineString(\n                            `Cannot deserialize ${objectName}:`,\n                            `'initializer' function returned undefined/null, but '${nameof(sourceObjectMetadata.classType)}' was expected.`\n                        ));\n                    }\n                    else if (!(targetObject instanceof sourceObjectMetadata.classType))\n                    {\n                        throw new TypeError(Helpers.multilineString(\n                            `Cannot deserialize ${objectName}:`,\n                            `'initializer' returned '${nameof(targetObject.constructor)}', but '${nameof(sourceObjectMetadata.classType)}' was expected,`,\n                            `and '${nameof(targetObject.constructor)}' is not a subtype of '${nameof(sourceObjectMetadata.classType)}'`\n                        ));\n                    }\n                }\n                catch (e)\n                {\n                    this._errorHandler(e);\n                    return undefined;\n                }\n            }\n            else\n            {\n                targetObject = this._instantiateType(expectedSelfType);\n            }\n\n            // Finally, assign deserialized properties to target object.\n            Object.assign(targetObject, sourceObjectWithDeserializedProperties);\n\n            // Call onDeserialized method (if any).\n            if (sourceObjectMetadata.onDeserializedMethodName)\n            {\n                if (typeof (targetObject.constructor as any)[sourceObjectMetadata.onDeserializedMethodName] === \"function\")\n                {\n                    (targetObject.constructor as any)[sourceObjectMetadata.onDeserializedMethodName]();\n                }\n                else\n                {\n                    this._errorHandler(new TypeError(\n                        `onDeserialized callback '${nameof(sourceObjectMetadata.classType)}.${sourceObjectMetadata.onDeserializedMethodName}' is not a method.`\n                    ));\n                }\n            }\n\n            return targetObject;\n        }\n        else\n        {\n            // Untyped deserialization into Object instance.\n            let targetObject = {} as IndexedObject;\n\n            Object.keys(sourceObject).forEach(sourceKey =>\n            {\n                targetObject[sourceKey] = this.convertSingleValue(sourceObject[sourceKey], {\n                    selfConstructor: sourceObject[sourceKey].constructor,\n                    knownTypes: sourceObjectTypeInfo.knownTypes,\n                    elementConstructor: sourceObjectTypeInfo.elementConstructor,\n                    keyConstructor: sourceObjectTypeInfo.keyConstructor\n                }, sourceKey);\n            });\n\n            return targetObject;\n        }\n    }\n\n    public convertSingleValue(sourceObject: Object, typeInfo: IScopeTypeInfo, memberName = \"object\")\n    {\n        let expectedSelfType = typeInfo.selfConstructor;\n        let srcTypeNameForDebug = sourceObject ? nameof(sourceObject.constructor) : \"undefined\";\n\n        if (!Helpers.isValueDefined(sourceObject))\n        {\n            return sourceObject;\n        }\n        else if (this._isDirectlyDeserializableNativeType(expectedSelfType))\n        {\n            if (sourceObject.constructor === expectedSelfType)\n            {\n                return sourceObject;\n            }\n            else\n            {\n                throw new TypeError(this._makeTypeErrorMessage(nameof(expectedSelfType), sourceObject.constructor, memberName));\n            }\n        }\n        else if (expectedSelfType === Date)\n        {\n            // Support for Date with ISO 8601 format, or with numeric timestamp (milliseconds elapsed since the Epoch).\n            // ISO 8601 spec.: https://www.w3.org/TR/NOTE-datetime\n\n            if (typeof sourceObject === \"string\" || (typeof sourceObject === \"number\" && sourceObject > 0))\n                return new Date(sourceObject as any);\n            else\n                this._throwTypeMismatchError(\"Date\", \"an ISO-8601 string\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Float32Array)\n        {\n            // Deserialize Float32Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Float32Array(sourceObject);\n            else\n                this._throwTypeMismatchError(\"Float32Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Float64Array)\n        {\n            // Deserialize Float64Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Float64Array(sourceObject);\n            else\n                this._throwTypeMismatchError(\"Float64Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint8Array)\n        {\n            // Deserialize Uint8Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Uint8Array(sourceObject.map(value => ~~value));\n            else\n                this._throwTypeMismatchError(\"Uint8Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint8ClampedArray)\n        {\n            // Deserialize Uint8Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Uint8ClampedArray(sourceObject.map(value => ~~value));\n            else\n                this._throwTypeMismatchError(\"Uint8ClampedArray\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint16Array)\n        {\n            // Deserialize Uint16Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Uint16Array(sourceObject.map(value => ~~value));\n            else\n                this._throwTypeMismatchError(\"Uint16Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint32Array)\n        {\n            // Deserialize Uint32Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Uint32Array(sourceObject.map(value => ~~value));\n            else\n                this._throwTypeMismatchError(\"Uint32Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === ArrayBuffer)\n        {\n            if (typeof sourceObject === \"string\")\n                return this._stringToArrayBuffer(sourceObject);\n            else\n                this._throwTypeMismatchError(\"ArrayBuffer\", \"a string source\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === DataView)\n        {\n            if (typeof sourceObject === \"string\")\n                return this._stringToDataView(sourceObject);\n            else\n                this._throwTypeMismatchError(\"DataView\", \"a string source\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Array)\n        {\n            if (sourceObject instanceof Array)\n                return this.convertAsArray(sourceObject, typeInfo, memberName);\n            else\n                throw new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName));\n        }\n        else if (expectedSelfType === Set)\n        {\n            if (sourceObject instanceof Array)\n                return this.convertAsSet(sourceObject, typeInfo, memberName);\n            else\n                this._throwTypeMismatchError(\"Set\", \"Array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Map)\n        {\n            if (sourceObject instanceof Array)\n                return this.convertAsMap(sourceObject, typeInfo, memberName);\n            else\n                this._throwTypeMismatchError(\"Map\", \"a source array of key-value-pair objects\", srcTypeNameForDebug, memberName);\n        }\n        else if (sourceObject && typeof sourceObject === \"object\")\n        {\n            return this.convertAsObject(sourceObject, typeInfo, memberName);\n        }\n    }\n\n    public convertAsArray(sourceObject: any, typeInfo: IScopeTypeInfo, memberName = \"object\"): any[]\n    {\n        if (!(sourceObject instanceof Array))\n        {\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n            return [];\n        }\n\n        if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Array: missing constructor reference of Array elements.`));\n            return [];\n        }\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            selfConstructor: typeInfo.elementConstructor[0],\n            elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n\n        return sourceObject.map(element =>\n        {\n            // If an array element fails to deserialize, substitute with undefined. This is so that the original ordering is not interrupted by faulty\n            // entries, as an Array is ordered.\n            try\n            {\n                return this.convertSingleValue(element, elementTypeInfo);\n            }\n            catch (e)\n            {\n                this._errorHandler(e);\n\n                // Keep filling the array here with undefined to keep original ordering.\n                // Note: this is just aesthetics, not returning anything produces the same result.\n                return undefined;\n            }\n        });\n    }\n\n    public convertAsSet(sourceObject: any, typeInfo: IScopeTypeInfo, memberName = \"object\")\n    {\n        if (!(sourceObject instanceof Array))\n        {\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n            return new Set<any>();\n        }\n\n        if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Set: missing constructor reference of Set elements.`));\n            return new Set<any>();\n        }\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            selfConstructor: typeInfo.elementConstructor[0],\n            elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n        let resultSet = new Set<any>();\n\n        sourceObject.forEach((element, i) =>\n        {\n            try\n            {\n                resultSet.add(this.convertSingleValue(element, elementTypeInfo, memberName + `[${i}]`));\n            }\n            catch (e)\n            {\n                // Faulty entries are skipped, because a Set is not ordered, and skipping an entry does not affect others.\n                this._errorHandler(e);\n            }\n        });\n\n        return resultSet;\n    }\n\n    public convertAsMap(sourceObject: any, typeInfo: IScopeTypeInfo, memberName = \"object\")\n    {\n        if (!(sourceObject instanceof Array))\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n\n        if (!typeInfo.keyConstructor)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Map: missing key constructor.`));\n            return new Map<any, any>();\n        }\n\n        if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Map: missing value constructor.`));\n            return new Map<any, any>();\n        }\n\n        let keyTypeInfo: IScopeTypeInfo = {\n            selfConstructor: typeInfo.keyConstructor,\n            knownTypes: typeInfo.knownTypes\n        };\n\n        let valueTypeInfo: IScopeTypeInfo = {\n            selfConstructor: typeInfo.elementConstructor[0],\n            elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n\n        let resultMap = new Map<any, any>();\n\n        sourceObject.forEach((element: any) =>\n        {\n            try\n            {\n                let key = this.convertSingleValue(element.key, keyTypeInfo);\n\n                // Undefined/null keys not supported, skip if so.\n                if (Helpers.isValueDefined(key))\n                {\n                    resultMap.set(key, this.convertSingleValue(element.value, valueTypeInfo, memberName + `[${key}]`));\n                }\n            }\n            catch (e)\n            {\n                // Faulty entries are skipped, because a Map is not ordered, and skipping an entry does not affect others.\n                this._errorHandler(e);\n            }\n        });\n\n        return resultMap;\n    }\n\n    private _throwTypeMismatchError(targetType: string, expectedSourceType: string, actualSourceType: string, memberName = \"object\")\n    {\n        throw new TypeError(`Could not deserialize ${memberName} as ${targetType}: expected ${expectedSourceType}, got ${actualSourceType}.`);\n    }\n\n    private _makeTypeErrorMessage(expectedType: Function | string, actualType: Function | string, memberName = \"object\")\n    {\n        let expectedTypeName = (typeof expectedType === \"function\") ? nameof(expectedType) : expectedType;\n        let actualTypeName = (typeof actualType === \"function\") ? nameof(actualType) : actualType;\n\n        return `Could not deserialize ${memberName}: expected '${expectedTypeName}', got '${actualTypeName}'.`;\n    }\n\n    private _instantiateType(ctor: any)\n    {\n        return new ctor();\n    }\n\n    private _mergeKnownTypes(...knownTypeMaps: Array<Map<string, Function>>)\n    {\n        let result = new Map<string, Function>();\n\n        knownTypeMaps.forEach(knownTypes =>\n        {\n            knownTypes.forEach((ctor, name) =>\n            {\n                if (this._nameResolver)\n                {\n                    result.set(this._nameResolver(ctor), ctor);\n                }\n                else\n                {\n                    result.set(name, ctor);\n                }\n            });\n        });\n\n        return result;\n    }\n\n    private _createKnownTypesMap(knowTypes: Set<Function>)\n    {\n        let map = new Map<string, Function>();\n\n        knowTypes.forEach(ctor =>\n        {\n            if (this._nameResolver)\n            {\n                map.set(this._nameResolver(ctor), ctor);\n            }\n            else\n            {\n                map.set(ctor.name, ctor);\n            }\n        });\n\n        return map;\n    }\n\n    private _isDirectlyDeserializableNativeType(ctor: any)\n    {\n        return ~([Number, String, Boolean].indexOf(ctor));\n    }\n\n    public convertNativeObject(sourceObject: any)\n    {\n        return sourceObject;\n    }\n\n    private _stringToArrayBuffer(str: string)\n    {\n        let buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n        let bufView = new Uint16Array(buf);\n\n        for (let i = 0, strLen = str.length; i < strLen; i++)\n        {\n            bufView[i] = str.charCodeAt(i);\n        }\n\n        return buf;\n    }\n\n    private _stringToDataView(str: string)\n    {\n        return new DataView(this._stringToArrayBuffer(str));\n    }\n}\n","import { nameof } from \"./helpers\";\nimport * as Helpers from \"./helpers\";\nimport { IndexedObject } from \"./types\";\nimport { JsonMemberMetadata, JsonObjectMetadata } from \"./metadata\";\n\nexport interface IScopeTypeInfo\n{\n    selfType: Function;\n    elementTypes?: Function[];\n    keyType?: Function;\n}\n\n/**\n * Utility class, converts a typed object tree (i.e. a tree of class instances, arrays of class instances, and so on) to an untyped javascript object (also\n * called \"simple javascript object\"), and emits any necessary type hints in the process (for polymorphism).\n *\n * The converted object tree is what will be given to `JSON.stringify` to convert to string as the last step, the serialization is basically like:\n *\n * (1) typed object-tree -> (2) simple JS object-tree -> (3) JSON-string\n */\nexport class Serializer\n{\n    private _typeHintEmitter: (targetObject: IndexedObject, sourceObject: IndexedObject, expectedSourceType: Function) => void;\n    private _errorHandler: (error: Error) => void;\n\n    constructor()\n    {\n        this._typeHintEmitter = (targetObject, sourceObject, expectedSourceType) =>\n        {\n            // By default, we put a \"__type\" property on the output object if the actual object is not the same as the expected one, so that deserialization\n            // will know what to deserialize into (given the required known-types are defined, and the object is a valid subtype of the expected type).\n            if (sourceObject.constructor !== expectedSourceType)\n            {\n                // TODO: Perhaps this can work correctly without string-literal access?\n                // tslint:disable-next-line:no-string-literal\n                targetObject[\"__type\"] = nameof(sourceObject.constructor);\n            }\n        };\n\n        this._errorHandler = (error) => Helpers.logError(error);\n    }\n\n    public setTypeHintEmitter(typeEmitterCallback: (targetObject: Object, sourceObject: Object, expectedSourceType: Function) => void)\n    {\n        if (typeof typeEmitterCallback !== \"function\")\n        {\n            throw new TypeError(\"'typeEmitterCallback' is not a function.\");\n        }\n\n        this._typeHintEmitter = typeEmitterCallback;\n    }\n\n    public setErrorHandler(errorHandlerCallback: (error: Error) => void)\n    {\n        if (typeof errorHandlerCallback !== \"function\")\n        {\n            throw new TypeError(\"'errorHandlerCallback' is not a function.\");\n        }\n\n        this._errorHandler = errorHandlerCallback;\n    }\n\n    /**\n     * Convert a value of any supported serializable type.\n     * The value type will be detected, and the correct serialization method will be called.\n     */\n    public convertSingleValue(sourceObject: any, typeInfo: IScopeTypeInfo, memberName: string = \"object\"): any\n    {\n        if (!Helpers.isValueDefined(sourceObject)) return;\n\n        if (!Helpers.isInstanceOf(sourceObject, typeInfo.selfType))\n        {\n            let expectedName = nameof(typeInfo.selfType);\n            let actualName = nameof(sourceObject.constructor);\n\n            this._errorHandler(new TypeError(`Could not serialize '${memberName}': expected '${expectedName}', got '${actualName}'.`));\n            return;\n        }\n\n        if (this._isDirectlySerializableNativeType(typeInfo.selfType))\n        {\n            return sourceObject;\n        }\n        else if (typeInfo.selfType === ArrayBuffer)\n        {\n            return this.convertAsArrayBuffer(sourceObject);\n        }\n        else if (typeInfo.selfType === DataView)\n        {\n            return this.convertAsDataView(sourceObject);\n        }\n        else if (typeInfo.selfType === Array)\n        {\n            return this.convertAsArray(sourceObject, typeInfo.elementTypes, memberName);\n        }\n        else if (typeInfo.selfType === Set)\n        {\n            return this.convertAsSet(sourceObject, typeInfo.elementTypes[0], memberName);\n        }\n        else if (typeInfo.selfType === Map)\n        {\n            return this.convertAsMap(sourceObject, typeInfo.keyType, typeInfo.elementTypes[0], memberName);\n        }\n        else if (this._isTypeTypedArray(typeInfo.selfType))\n        {\n            return this.convertAsTypedArray(sourceObject);\n        }\n        else if (typeof sourceObject === \"object\")\n        {\n            return this.convertAsObject(sourceObject, typeInfo, memberName);\n        }\n    }\n\n    /**\n     * Performs the conversion of a typed object (usually a class instance) to a simple javascript object for serialization.\n     */\n    public convertAsObject(sourceObject: IndexedObject, typeInfo: IScopeTypeInfo, memberName?: string)\n    {\n        let sourceTypeMetadata: JsonObjectMetadata;\n        let targetObject: IndexedObject;\n\n        if (sourceObject.constructor !== typeInfo.selfType && sourceObject instanceof typeInfo.selfType)\n        {\n            // The source object is not of the expected type, but it is a valid subtype.\n            // This is OK, and we'll proceed to gather object metadata from the subtype instead.\n            sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(sourceObject.constructor);\n        }\n        else\n        {\n            sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(typeInfo.selfType);\n        }\n\n        if (sourceTypeMetadata)\n        {\n            // Strong-typed serialization available.\n            // We'll serialize by members that have been marked with @jsonMember (including array/set/map members), and perform recursive conversion on\n            // each of them. The converted objects are put on the 'targetObject', which is what will be put into 'JSON.stringify' finally.\n            targetObject = {};\n\n            sourceTypeMetadata.dataMembers.forEach((memberMetadata, propKey) =>\n            {\n                if (memberMetadata.serializer) {\n                    targetObject[memberMetadata.name] = memberMetadata.serializer(sourceObject[memberMetadata.key]);\n                } else {\n                    targetObject[memberMetadata.name] = this.convertSingleValue(sourceObject[memberMetadata.key], {\n                        selfType: memberMetadata.ctor,\n                        elementTypes: memberMetadata.elementType,\n                        keyType: memberMetadata.keyType\n                    }, `${nameof(sourceTypeMetadata.classType)}.${memberMetadata.key}`);\n                }\n            });\n        }\n        else\n        {\n            // Untyped serialization, \"as-is\", we'll just pass the object on.\n            // We'll clone the source object, because type hints are added to the object itself, and we don't want to modify to the original object.\n            targetObject = { ...sourceObject };\n        }\n\n        // Add type-hint.\n        this._typeHintEmitter(targetObject, sourceObject, typeInfo.selfType);\n\n        return targetObject;\n    }\n\n    /**\n     * Performs the conversion of an array of typed objects (or primitive values) to an array of simple javascript objects (or primitive values) for\n     * serialization.\n     * @param expectedElementType The expected type of elements. If the array is supposed to be multi-dimensional, subsequent elements define lower dimensions.\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     */\n    public convertAsArray(sourceObject: any[], expectedElementType: Function[], memberName = \"object\")\n    {\n        if (expectedElementType.length === 0 || !expectedElementType[0])\n        {\n            this._errorHandler(new TypeError(`Could not serialize ${memberName} as Array: missing element type definition.`));\n            return;\n        }\n\n        // Check the type of each element, individually.\n        // If at least one array element type is incorrect, we return undefined, which results in no value emitted during serialization.\n        // This is so that invalid element types don't unexpectedly alter the ordering of other, valid elements, and that no unexpected undefined values are in\n        // the emitted array.\n        try\n        {\n            sourceObject.forEach((element, i) =>\n            {\n                if (!Helpers.isInstanceOf(element, expectedElementType[0]))\n                {\n                    let expectedTypeName = nameof(expectedElementType[0]);\n                    let actualTypeName = nameof(element.constructor);\n                    throw new TypeError(`Could not serialize ${memberName}[${i}]: expected '${expectedTypeName}', got '${actualTypeName}'.`);\n                }\n            });\n        }\n        catch (e)\n        {\n            this._errorHandler(e);\n            return;\n        }\n\n        let typeInfoForElements: IScopeTypeInfo = {\n            selfType: expectedElementType[0],\n            elementTypes: expectedElementType.length > 1 ? expectedElementType.slice(1) : [] // For multidimensional arrays.\n        };\n\n        if (memberName)\n        {\n            // Just for debugging purposes.\n            memberName += \"[]\";\n        }\n\n        return sourceObject.map(element => this.convertSingleValue(element, typeInfoForElements, memberName));\n    }\n\n    /**\n     * Performs the conversion of a set of typed objects (or primitive values) into an array of simple javascript objects.\n     *\n     * @param sourceObject\n     * @param expectedElementType The constructor of the expected Set elements (e.g. `Number` for `Set<number>`, or `MyClass` for `Set<MyClass>`).\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @returns\n     */\n    public convertAsSet(sourceObject: Set<any>, expectedElementType: Function, memberName = \"object\")\n    {\n        if (!expectedElementType)\n        {\n            this._errorHandler(new TypeError(`Could not serialize ${memberName} as Set: missing element type definition.`));\n            return;\n        }\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            selfType: expectedElementType\n        };\n\n        // For debugging and error tracking.\n        if (memberName) memberName += \"[]\";\n\n        let resultArray: any[] = [];\n\n        // Convert each element of the set, and put it into an output array.\n        // The output array is the one serialized, as JSON.stringify does not support Set serialization. (TODO: clarification needed)\n        sourceObject.forEach(element =>\n        {\n            let resultElement = this.convertSingleValue(element, elementTypeInfo, memberName);\n\n            // Add to output if the source element was undefined, OR the converted element is defined. This will add intentionally undefined values to output,\n            // but not values that became undefined DURING serializing (usually because of a type-error).\n            if (!Helpers.isValueDefined(element) || Helpers.isValueDefined(resultElement))\n            {\n                resultArray.push(resultElement);\n            }\n        });\n\n        return resultArray;\n    }\n\n    /**\n     * Performs the conversion of a map of typed objects (or primitive values) into an array of simple javascript objects with `key` and `value` properties.\n     *\n     * @param sourceObject\n     * @param expectedKeyType The constructor of the expected Map keys (e.g. `Number` for `Map<number, any>`, or `MyClass` for `Map<MyClass, any>`).\n     * @param expectedElementType The constructor of the expected Map values (e.g. `Number` for `Map<any, number>`, or `MyClass` for `Map<any, MyClass>`).\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     */\n    public convertAsMap(sourceObject: Map<any, any>, expectedKeyType: Function, expectedElementType: Function, memberName = \"object\")\n    {\n        if (!expectedElementType)\n            throw new TypeError(`Could not serialize ${memberName} as Map: missing value type definition.`);\n\n        if (!expectedKeyType)\n            throw new TypeError(`Could not serialize ${memberName} as Map: missing key type definition.`);\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            selfType: expectedElementType,\n            elementTypes: [expectedElementType]\n        };\n\n        let keyTypeInfo: IScopeTypeInfo = {\n            selfType: expectedKeyType\n        };\n\n        if (memberName) memberName += \"[]\";\n\n        let resultArray: Array<{ key: any, value: any }> = [];\n\n        // Convert each *entry* in the map to a simple javascript object with key and value properties.\n        sourceObject.forEach((value, key) =>\n        {\n            let resultKeyValuePairObj = {\n                key: this.convertSingleValue(key, keyTypeInfo, memberName),\n                value: this.convertSingleValue(value, elementTypeInfo, memberName)\n            };\n\n            // We are not going to emit entries with undefined keys OR undefined values.\n            if (Helpers.isValueDefined(resultKeyValuePairObj.key) && Helpers.isValueDefined(resultKeyValuePairObj.value))\n            {\n                resultArray.push(resultKeyValuePairObj);\n            }\n        });\n\n        return resultArray;\n    }\n\n    /**\n     * Performs the conversion of a typed javascript array to a simple untyped javascript array.\n     * This is needed because typed arrays are otherwise serialized as objects, so we'll end up with something like \"{ 0: 0, 1: 1, ... }\".\n     *\n     * @param sourceObject\n     * @returns\n     */\n    public convertAsTypedArray(sourceObject: ArrayBufferView)\n    {\n        return Array.from(sourceObject as any);\n    }\n\n    /**\n     * Performs the conversion of a raw ArrayBuffer to a string.\n     */\n    public convertAsArrayBuffer(buffer: ArrayBuffer)\n    {\n        // ArrayBuffer -> 16-bit character codes -> character array -> joined string.\n        return Array.from(new Uint16Array(buffer)).map(charCode => String.fromCharCode(charCode)).join(\"\");\n    }\n\n    /**\n     * Performs the conversion of DataView, converting its internal ArrayBuffer to a string and returning that string.\n     */\n    public convertAsDataView(dataView: DataView)\n    {\n        return this.convertAsArrayBuffer(dataView.buffer);\n    }\n\n    /**\n     * Determines whether the specified type is a type that can be passed on \"as-is\" into `JSON.stringify`.\n     * Values of these types don't need special conversion.\n     * @param ctor The constructor of the type (wrapper constructor for primitive types, e.g. `Number` for `number`).\n     */\n    private _isDirectlySerializableNativeType(ctor: Function)\n    {\n        return ~[Date, Number, String, Boolean].indexOf(ctor as any);\n    }\n\n    private _isTypeTypedArray(ctor: Function)\n    {\n        return ~[Float32Array, Float64Array, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array].indexOf(ctor as any);\n    }\n}\n","import { nameof } from \"./helpers\";\nimport * as Helpers from \"./helpers\";\nimport { JsonObjectMetadata } from \"./metadata\";\nimport { Constructor, ParameterlessConstructor } from \"./types\";\n\nexport interface IJsonObjectOptionsWithInitializer<T>\n{\n    /** An array of known types to recognize when encountering type-hints, or the name of a static method used for determining known types. */\n    knownTypes?: Function[] | string;\n\n    /** The name of a static or instance method to call when deserialization of the object is completed. */\n    onDeserialized?: string;\n\n    /**\n     * The name of a static method to call before deserializing and initializing the object, accepting two arguments: (1) sourceObject, an 'Object' instance\n     * with all properties already deserialized, and (2) rawSourceObject, a raw 'Object' instance representation of the current object in the serialized JSON\n     * (i.e. without deserialized properties).\n     */\n    initializer: (sourceObject: T, rawSourceObject: T) => T;\n\n    name?: string;\n}\n\nexport interface IJsonObjectOptions<T>\n{\n    /** An array of known types to recognize when encountering type-hints, or the name of a static method used for determining known types. */\n    knownTypes?: Function[] | string;\n\n    /** The name of a static or instance method to call when deserialization of the object is completed. */\n    onDeserialized?: string;\n\n    /**\n     * The name of a static method to call before deserializing and initializing the object, accepting two arguments: (1) sourceObject, an 'Object' instance\n     * with all properties already deserialized, and (2) rawSourceObject, a raw 'Object' instance representation of the current object in the serialized JSON\n     * (i.e. without deserialized properties).\n     */\n    initializer?: (sourceObject: T, rawSourceObject: T) => T;\n\n    name?: string;\n}\n\n/**\n * Marks that a class with a parameterized constructor is serializable using TypedJSON, with additional settings. The 'initializer' setting must be specified.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(options?: IJsonObjectOptionsWithInitializer<T>): (target: Constructor<T>) => void;\n\n/**\n * Marks that a class is serializable using TypedJSON, with additional settings.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(options?: IJsonObjectOptions<T>): (target: ParameterlessConstructor<T>) => void;\n\n/**\n * Marks that a class with a parameterless constructor is serializable using TypedJSON.\n */\nexport function jsonObject<T>(target: ParameterlessConstructor<T>): void;\n\nexport function jsonObject<T>(optionsOrTarget?: IJsonObjectOptions<T> | Constructor<T>): (target: Constructor<T>) => void | void\n{\n    let options: IJsonObjectOptions<T>;\n\n    if (typeof optionsOrTarget === \"function\")\n    {\n        // jsonObject is being used as a decorator, directly.\n        options = {};\n    }\n    else\n    {\n        // jsonObject is being used as a decorator factory.\n        options = optionsOrTarget || {};\n    }\n\n    let decorator = function (target: Function): void\n    {\n        let objectMetadata: JsonObjectMetadata;\n        let parentMetadata: JsonObjectMetadata;\n\n        // Create or obtain JsonObjectMetadata object.\n        if (!target.prototype.hasOwnProperty(Helpers.METADATA_FIELD_KEY))\n        {\n            // Target has no JsonObjectMetadata associated with it yet, create it now.\n            objectMetadata = new JsonObjectMetadata();\n            parentMetadata = target.prototype[Helpers.METADATA_FIELD_KEY];\n\n            // Inherit json members and known types from parent @jsonObject (if any).\n            if (parentMetadata)\n            {\n                parentMetadata.dataMembers.forEach((memberMetadata, propKey) => objectMetadata.dataMembers.set(propKey, memberMetadata));\n                parentMetadata.knownTypes.forEach((knownType) => objectMetadata.knownTypes.add(knownType));\n            }\n\n            if (options.name)\n            {\n                objectMetadata.name = options.name;\n            }\n            else\n            {\n                objectMetadata.name = target.name;\n            }\n\n            Object.defineProperty(target.prototype, Helpers.METADATA_FIELD_KEY, {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: objectMetadata\n            });\n        }\n        else\n        {\n            // Target already has JsonObjectMetadata associated with it.\n            objectMetadata = target.prototype[Helpers.METADATA_FIELD_KEY];\n\n            if (options.name)\n            {\n                objectMetadata.name = options.name;\n            }\n        }\n\n        // Fill JsonObjectMetadata.\n        objectMetadata.classType = target;\n        objectMetadata.isExplicitlyMarked = true;\n        objectMetadata.isAbstract = false;\n        objectMetadata.initializerCallback = options.initializer;\n\n        // Obtain known-types.\n        if (typeof options.knownTypes === \"string\")\n        {\n            objectMetadata.knownTypeMethodName = options.knownTypes;\n        }\n        else if (options.knownTypes instanceof Array)\n        {\n            options.knownTypes.filter(knownType => !!knownType).forEach(knownType => objectMetadata.knownTypes.add(knownType));\n        }\n    };\n\n    if (typeof optionsOrTarget === \"function\")\n    {\n        // jsonObject is being used as a decorator, directly.\n        decorator(optionsOrTarget);\n    }\n    else\n    {\n        // jsonObject is being used as a decorator factory.\n        return decorator;\n    }\n}\n","import { nameof } from \"./helpers\";\nimport { JsonMemberMetadata, injectMetadataInformation } from \"./metadata\";\nimport * as Helpers from \"./helpers\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMemberOptions\n{\n    /**\n     * Sets the constructor of the property.\n     * Optional with ReflectDecorators.\n     */\n    constructor?: Function;\n\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted if the property is uninitialized/undefined. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name. */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property is part of the object when serializing, with additional options.\n * Omitting the 'constructor' option requires ReflectDecorators and that the property type is always explicitly declared.\n * @param options Additional options.\n */\nexport function jsonMember<TFunction extends Function>(options: IJsonMemberOptions): PropertyDecorator;\n\n/**\n * Specifies that a property is part of the object when serializing.\n * This call signature requires ReflectDecorators and that the property type is always explicitly declared.\n */\nexport function jsonMember(target: Object, propertyKey: string | symbol): void;\n\nexport function jsonMember<TFunction extends Function>(optionsOrTarget?: IJsonMemberOptions | Object, propKey?: string | symbol): PropertyDecorator | void\n{\n    if (optionsOrTarget instanceof Object && (typeof propKey === \"string\" || typeof propKey === \"symbol\"))\n    {\n        let target = optionsOrTarget;\n        let decoratorName = `@jsonMember on ${nameof(target.constructor)}.${propKey}`; // For error messages.\n\n        // jsonMember used directly, no additional information directly available besides target and propKey.\n        // Obtain property constructor through ReflectDecorators.\n        if (Helpers.isReflectMetadataSupported)\n        {\n            let reflectPropCtor = Reflect.getMetadata(\"design:type\", target, propKey) as Function;\n            let memberMetadata = new JsonMemberMetadata();\n\n            if (!reflectPropCtor)\n            {\n                Helpers.logError(`${decoratorName}: could not resolve detected property constructor at runtime.`);\n                return;\n            }\n\n            if (isSpecialPropertyType(reflectPropCtor, decoratorName))\n            {\n                return;\n            }\n\n            memberMetadata.ctor = reflectPropCtor;\n            memberMetadata.key = propKey.toString();\n            memberMetadata.name = propKey.toString();\n\n            injectMetadataInformation(target, propKey, memberMetadata);\n        }\n        else\n        {\n            Helpers.logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is specified.`);\n            return;\n        }\n    }\n    else\n    {\n        // jsonMember used as a decorator factory.\n        return (target: Object, _propKey: string | symbol) =>\n        {\n            let options: IJsonMemberOptions = optionsOrTarget || {};\n            let propCtor: Function;\n            let decoratorName = `@jsonMember on ${nameof(target.constructor)}.${_propKey}`; // For error messages.\n\n            if (options.hasOwnProperty(\"constructor\"))\n            {\n                if (!Helpers.isValueDefined(options.constructor))\n                {\n                    Helpers.logError(`${decoratorName}: cannot resolve specified property constructor at runtime.`);\n                    return;\n                }\n\n                // Property constructor has been specified. Use ReflectDecorators (if available) to check whether that constructor is correct. Warn if not.\n                if (Helpers.isReflectMetadataSupported && !Helpers.isSubtypeOf(options.constructor, Reflect.getMetadata(\"design:type\", target, _propKey)))\n                {\n                    Helpers.logWarning(`${decoratorName}: detected property type does not match 'constructor' option.`);\n                }\n\n                propCtor = options.constructor;\n            }\n            else\n            {\n                // Use ReflectDecorators to obtain property constructor.\n                if (Helpers.isReflectMetadataSupported)\n                {\n                    propCtor = Reflect.getMetadata(\"design:type\", target, _propKey) as Function;\n\n                    if (!propCtor)\n                    {\n                        Helpers.logError(`${decoratorName}: cannot resolve detected property constructor at runtime.`);\n                        return;\n                    }\n                }\n                else if (!options.deserializer)\n                {\n                    Helpers.logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is specified.`);\n                    return;\n                }\n            }\n\n            if (isSpecialPropertyType(propCtor, decoratorName))\n            {\n                return;\n            }\n\n            let memberMetadata = new JsonMemberMetadata();\n\n            memberMetadata.ctor = propCtor;\n            memberMetadata.emitDefaultValue = options.emitDefaultValue || false;\n            memberMetadata.isRequired = options.isRequired || false;\n            memberMetadata.key = _propKey.toString();\n            memberMetadata.name = options.name || _propKey.toString();\n            memberMetadata.deserializer = options.deserializer;\n            memberMetadata.serializer = options.serializer;\n\n            injectMetadataInformation(target, _propKey, memberMetadata);\n        };\n    }\n}\n\nfunction isSpecialPropertyType(propCtor: Function, decoratorName: string)\n{\n    if (propCtor === Array)\n    {\n        Helpers.logError(`${decoratorName}: property is an Array. Use the jsonArrayMember decorator to serialize this property.`);\n        return true;\n    }\n\n    if (propCtor === Set)\n    {\n        Helpers.logError(`${decoratorName}: property is a Set. Use the jsonSetMember decorator to serialize this property.`);\n        return true;\n    }\n\n    if (propCtor === Map)\n    {\n        Helpers.logError(`${decoratorName}: property is a Map. Use the jsonMapMember decorator to serialize this property.`);\n        return true;\n    }\n\n    return false;\n}\n","import { nameof } from \"./helpers\";\nimport { IJsonMemberOptions } from \"./json-member\";\nimport { JsonMemberMetadata, JsonObjectMetadata, injectMetadataInformation } from \"./metadata\";\nimport * as Helpers from \"./helpers\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonArrayMemberOptions\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, an empty array is emitted if the property is undefined/uninitialized. */\n    emitDefaultValue?: boolean;\n\n    /** Sets array dimensions (e.g. 1 for 'number[]' or 2 for 'number[][]'). Defaults to 1. */\n    dimensions?: number;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property, of type array, is part of an object when serializing.\n * @param elementConstructor Constructor of array elements (e.g. 'Number' for 'number[]', or 'Date' for 'Date[]').\n * @param options Additional options.\n */\nexport function jsonArrayMember(elementConstructor: Function, options: IJsonArrayMemberOptions = {})\n{\n    return (target: Object, propKey: string | symbol) =>\n    {\n        let decoratorName = `@jsonArrayMember on ${nameof(target.constructor)}.${propKey}`; // For error messages.\n\n        if (typeof elementConstructor !== \"function\")\n        {\n            Helpers.logError(`${decoratorName}: could not resolve constructor of array elements at runtime.`);\n            return;\n        }\n\n        if (!isNaN(options.dimensions) && options.dimensions < 1)\n        {\n            Helpers.logError(`${decoratorName}: 'dimensions' option must be at least 1.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonArrayMember' has been used on an array.\n        if (Helpers.isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Array)\n        {\n            Helpers.logError(`${decoratorName}: property is not an Array.`);\n            return;\n        }\n\n        let metadata = new JsonMemberMetadata();\n\n        metadata.ctor = Array;\n\n        if (options.dimensions && options.dimensions >= 1)\n        {\n            metadata.elementType = [];\n\n            for (let i = 1; i < options.dimensions; i++)\n            {\n                metadata.elementType.push(Array);\n            }\n\n            metadata.elementType.push(elementConstructor);\n        }\n        else\n        {\n            metadata.elementType = [elementConstructor];\n        }\n\n        metadata.emitDefaultValue = options.emitDefaultValue || false;\n        metadata.isRequired = options.isRequired || false;\n        metadata.key = propKey.toString();\n        metadata.name = options.name || propKey.toString();\n        metadata.deserializer = options.deserializer;\n        metadata.serializer = options.serializer;\n\n        injectMetadataInformation(target, propKey, metadata);\n    };\n}\n","import { nameof } from \"./helpers\";\nimport { IJsonMemberOptions } from \"./json-member\";\nimport { JsonMemberMetadata, JsonObjectMetadata, injectMetadataInformation } from \"./metadata\";\nimport * as Helpers from \"./helpers\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonSetMemberOptions\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Set<T>.\n * @param elementConstructor Constructor of set elements (e.g. 'Number' for Set<number> or 'Date' for Set<Date>).\n * @param options Additional options.\n */\nexport function jsonSetMember(elementConstructor: Function, options: IJsonSetMemberOptions = {})\n{\n    return (target: Object, propKey: string | symbol) =>\n    {\n        var decoratorName = `@jsonSetMember on ${nameof(target.constructor)}.${propKey}`; // For error messages.\n\n        if (typeof elementConstructor !== \"function\")\n        {\n            Helpers.logError(`${decoratorName}: could not resolve constructor of set elements at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonSetMember' has been used on a set. Warn if not.\n        if (Helpers.isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Set)\n        {\n            Helpers.logError(`${decoratorName}: property is not a Set.`);\n            return;\n        }\n\n        var metadata = new JsonMemberMetadata();\n\n        metadata.ctor = Set;\n        metadata.elementType = [elementConstructor];\n        metadata.emitDefaultValue = options.emitDefaultValue || false;\n        metadata.isRequired = options.isRequired || false;\n        metadata.key = propKey.toString();\n        metadata.name = options.name || propKey.toString();\n        metadata.deserializer = options.deserializer;\n        metadata.serializer = options.serializer;\n\n        injectMetadataInformation(target, propKey, metadata);\n    };\n}\n","import { nameof } from \"./helpers\";\nimport { IJsonMemberOptions } from \"./json-member\";\nimport { JsonMemberMetadata, JsonObjectMetadata, injectMetadataInformation } from \"./metadata\";\nimport * as Helpers from \"./helpers\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMapMemberOptions\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Map<K, V>.\n * @param keyConstructor Constructor of map keys (e.g. 'Number' for 'Map<number, Date>').\n * @param valueConstructor Constructor of map values (e.g. 'Date' for 'Map<number, Date>').\n * @param options Additional options.\n */\nexport function jsonMapMember(keyConstructor: Function, valueConstructor: Function, options: IJsonMapMemberOptions = {})\n{\n    return (target: Object, propKey: string | symbol) =>\n    {\n        let decoratorName = `@jsonMapMember on ${nameof(target.constructor)}.${propKey}`; // For error messages.\n\n        if (typeof keyConstructor !== \"function\")\n        {\n            Helpers.logError(`${decoratorName}: could not resolve constructor of map keys at runtime.`);\n            return;\n        }\n\n        if (typeof valueConstructor !== \"function\")\n        {\n            Helpers.logError(`${decoratorName}: could not resolve constructor of map values at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonMapMember' has been used on a map. Warn if not.\n        if (Helpers.isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Map)\n        {\n            Helpers.logError(`${decoratorName}: property is not a Map.`);\n            return;\n        }\n\n        let metadata = new JsonMemberMetadata();\n\n        metadata.ctor = Map;\n        metadata.elementType = [valueConstructor];\n        metadata.keyType = keyConstructor;\n        metadata.emitDefaultValue = options.emitDefaultValue || false;\n        metadata.isRequired = options.isRequired || false;\n        metadata.key = propKey.toString();\n        metadata.name = options.name || propKey.toString();\n        metadata.deserializer = options.deserializer;\n        metadata.serializer = options.serializer;\n\n        injectMetadataInformation(target, propKey, metadata);\n    };\n}\n","import { parseToJSObject } from './typedjson/helpers';\nimport { Constructor } from \"./typedjson/types\";\nimport * as Helpers from \"./typedjson/helpers\";\nimport { JsonObjectMetadata } from \"./typedjson/metadata\";\nimport { Deserializer } from \"./typedjson/deserializer\";\nimport { Serializer } from \"./typedjson/serializer\";\n\nexport interface ITypedJSONSettings\n{\n    /**\n     * Sets the handler callback to invoke on errors during serializing and deserializing.\n     * Re-throwing errors in this function will halt serialization/deserialization.\n     * The default behavior is to log errors to the console.\n     */\n    errorHandler?: (e: Error) => void;\n\n    /**\n     * Sets a callback that determines the constructor of the correct sub-type of polymorphic objects while deserializing.\n     * The default behavior is to read the type-name from the '__type' property of 'sourceObject', and look it up in 'knownTypes'.\n     * The constructor of the sub-type should be returned.\n     */\n    typeResolver?: (sourceObject: Object, knownTypes: Map<string, Function>) => Function;\n\n    nameResolver?: (ctor: Function) => string;\n\n    /**\n     * Sets a callback that writes type-hints to serialized objects.\n     * The default behavior is to write the type-name to the '__type' property, if a derived type is present in place of a base type.\n     */\n    typeHintEmitter?: (targetObject: Object, sourceObject: Object, expectedSourceType: Function) => void;\n\n    /**\n     * Sets the amount of indentation to use in produced JSON strings.\n     * Default value is 0, or no indentation.\n     */\n    indent?: number;\n\n    replacer?: (key: string, value: any) => any;\n\n    knownTypes?: Array<Constructor<any>>;\n}\n\nexport class TypedJSON<T>\n{\n    //#region Static\n    public static parse<T>(json: any, rootType: Constructor<T>, settings?: ITypedJSONSettings)\n    {\n        const object = parseToJSObject(json);\n        return new TypedJSON(rootType, settings).parse(object);\n    }\n\n    public static parseAsArray<T>(json: any, elementType: Constructor<T>, settings?: ITypedJSONSettings): T[]\n    {\n        const object = parseToJSObject(json);\n        return new TypedJSON(elementType, settings).parseAsArray(object);\n    }\n\n    public static parseAsSet<T>(json: any, elementType: Constructor<T>, settings?: ITypedJSONSettings): Set<T>\n    {\n        const object = parseToJSObject(json);\n        return new TypedJSON(elementType, settings).parseAsSet(object);\n    }\n\n    public static parseAsMap<K, V>(json: any, keyType: Constructor<K>, valueType: Constructor<V>, settings?: ITypedJSONSettings): Map<K, V>\n    {\n        const object = parseToJSObject(json);\n        return new TypedJSON(valueType, settings).parseAsMap(object, keyType);\n    }\n\n    public static stringify<T>(object: T, rootType: Constructor<T>, settings?: ITypedJSONSettings)\n    {\n        return new TypedJSON(rootType, settings).stringify(object);\n    }\n\n    public static stringifyAsArray<T>(object: T[], elementType: Constructor<T>, dimensions?: 1, settings?: ITypedJSONSettings): string;\n    public static stringifyAsArray<T>(object: T[][], elementType: Constructor<T>, dimensions: 2, settings?: ITypedJSONSettings): string;\n    public static stringifyAsArray<T>(object: T[][][], elementType: Constructor<T>, dimensions: 3, settings?: ITypedJSONSettings): string;\n    public static stringifyAsArray<T>(object: T[][][][], elementType: Constructor<T>, dimensions: 4, settings?: ITypedJSONSettings): string;\n    public static stringifyAsArray<T>(object: T[][][][][], elementType: Constructor<T>, dimensions: 5, settings?: ITypedJSONSettings): string;\n    public static stringifyAsArray<T>(object: any[], elementType: Constructor<T>, dimensions: number = 1, settings?: ITypedJSONSettings): string\n    {\n        return new TypedJSON(elementType, settings).stringifyAsArray(object, dimensions as any);\n    }\n\n    public static stringifyAsSet<T>(object: Set<T>, elementType: Constructor<T>, settings?: ITypedJSONSettings): string\n    {\n        return new TypedJSON(elementType, settings).stringifyAsSet(object);\n    }\n\n    public static stringifyAsMap<K, V>(object: Map<K, V>, keyCtor: Constructor<K>, valueCtor: Constructor<V>, settings?: ITypedJSONSettings): string\n    {\n        return new TypedJSON(valueCtor, settings).stringifyAsMap(object, keyCtor);\n    }\n\n    private static _globalConfig: ITypedJSONSettings;\n\n    public static setGlobalConfig(config: ITypedJSONSettings)\n    {\n        if (this._globalConfig)\n        {\n            Object.assign(this._globalConfig, config);\n        }\n        else\n        {\n            this._globalConfig = config;\n        }\n    }\n\n    //#endregion\n\n    private serializer: Serializer = new Serializer();\n    private deserializer: Deserializer<T> = new Deserializer<T>();\n    private globalKnownTypes: Array<Constructor<any>> = [];\n    private indent: number = 0;\n    private rootConstructor: Constructor<T>;\n    private errorHandler: (e: Error) => void;\n    private nameResolver: (ctor: Function) => string;\n    private replacer: (key: string, value: any) => any;\n\n    /**\n     * Creates a new TypedJSON instance to serialize (stringify) and deserialize (parse) object instances of the specified root class type.\n     * @param rootType The constructor of the root class type.\n     * @param settings Additional configuration settings.\n     */\n    constructor(rootConstructor: Constructor<T>, settings?: ITypedJSONSettings)\n    {\n        let rootMetadata = JsonObjectMetadata.getFromConstructor(rootConstructor);\n\n        if (!rootMetadata || !rootMetadata.isExplicitlyMarked)\n        {\n            throw new TypeError(\"The TypedJSON root data type must have the @jsonObject decorator used.\");\n        }\n\n        this.nameResolver = (ctor) => Helpers.nameof(ctor);\n        this.rootConstructor = rootConstructor;\n        this.errorHandler = (error) => Helpers.logError(error);\n\n        if (settings)\n        {\n            this.config(settings);\n        }\n        else if (TypedJSON._globalConfig)\n        {\n            this.config({});\n        }\n    }\n\n    /**\n     * Configures TypedJSON through a settings object.\n     * @param settings The configuration settings object.\n     */\n    public config(settings: ITypedJSONSettings)\n    {\n        if (TypedJSON._globalConfig)\n        {\n            settings = {\n                ...TypedJSON._globalConfig,\n                ...settings\n            };\n\n            if (settings.knownTypes && TypedJSON._globalConfig.knownTypes)\n            {\n                // Merge known-types (also de-duplicate them, so Array -> Set -> Array).\n                settings.knownTypes = Array.from(new Set(settings.knownTypes.concat(TypedJSON._globalConfig.knownTypes)));\n            }\n        }\n\n        if (settings.errorHandler)\n        {\n            this.errorHandler = settings.errorHandler;\n            this.deserializer.setErrorHandler(settings.errorHandler);\n            this.serializer.setErrorHandler(settings.errorHandler);\n        }\n\n        if (settings.replacer) this.replacer = settings.replacer;\n        if (settings.typeResolver) this.deserializer.setTypeResolver(settings.typeResolver);\n        if (settings.typeHintEmitter) this.serializer.setTypeHintEmitter(settings.typeHintEmitter);\n        if (settings.indent) this.indent = settings.indent;\n\n        if (settings.nameResolver)\n        {\n            this.nameResolver = settings.nameResolver;\n            this.deserializer.setNameResolver(settings.nameResolver);\n            // this.serializer.set\n        }\n\n        if (settings.knownTypes)\n        {\n            // Type-check knownTypes elements to recognize errors in advance.\n            settings.knownTypes.forEach((knownType, i) =>\n            {\n                // tslint:disable-next-line:no-null-keyword\n                if (typeof knownType === \"undefined\" || knownType === null)\n                {\n                    Helpers.logWarning(`TypedJSON.config: 'knownTypes' contains an undefined/null value (element ${i}).`);\n                }\n            });\n\n            this.globalKnownTypes = settings.knownTypes;\n        }\n    }\n\n    /**\n     * Converts a JSON string to the root class type.\n     * @param object The JSON to parse and convert.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     */\n    public parse(object: Object): T\n    {\n        let rootMetadata = JsonObjectMetadata.getFromConstructor(this.rootConstructor);\n        let result: T;\n        let knownTypes = new Map<string, Function>();\n\n        this.globalKnownTypes.filter(ktc => ktc).forEach(knownTypeCtor =>\n        {\n            knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n        });\n\n        if (rootMetadata)\n        {\n            rootMetadata.knownTypes.forEach(knownTypeCtor =>\n            {\n                knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n            });\n        }\n\n        try\n        {\n            result = this.deserializer.convertSingleValue(object, {\n                selfConstructor: this.rootConstructor,\n                knownTypes: knownTypes\n            }) as T;\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n\n        return result;\n    }\n\n    public parseAsArray(object: Object, dimensions: number = 1): T[]\n    {\n        if (object instanceof Array)\n        {\n            return this.deserializer.convertAsArray(object, {\n                selfConstructor: Array,\n                elementConstructor: new Array((dimensions - 1) || 0).fill(Array).concat(this.rootConstructor),\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes)\n            });\n        }\n        else\n        {\n            this.errorHandler(new TypeError(`Expected 'json' to define an Array, but got ${typeof object}.`));\n        }\n\n        return [];\n    }\n\n    public parseAsSet(object: Object): Set<T>\n    {\n        // A Set<T> is serialized as T[].\n        if (object instanceof Array)\n        {\n            return this.deserializer.convertAsSet(object, {\n                selfConstructor: Array,\n                elementConstructor: [this.rootConstructor],\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes)\n            });\n        }\n        else\n        {\n            this.errorHandler(new TypeError(`Expected 'json' to define a Set (using an Array), but got ${typeof object}.`));\n        }\n\n        return new Set<T>();\n    }\n\n    public parseAsMap<K>(object: Object, keyConstructor: Constructor<K>): Map<K, T>\n    {\n        // A Set<T> is serialized as T[].\n        if (object instanceof Array)\n        {\n            return this.deserializer.convertAsMap(object, {\n                selfConstructor: Array,\n                elementConstructor: [this.rootConstructor],\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes),\n                keyConstructor: keyConstructor\n            });\n        }\n        else\n        {\n            this.errorHandler(new TypeError(`Expected 'json' to define a Set (using an Array), but got ${typeof object}.`));\n        }\n\n        return new Map<K, T>();\n    }\n\n    /**\n     * Converts an instance of the specified class type to a JSON string.\n     * @param object The instance to convert to a JSON string.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     */\n    public stringify(object: T): string\n    {\n        let serializedObject: Object;\n\n        if (!(object as any instanceof this.rootConstructor))\n        {\n            this.errorHandler(TypeError(`Expected object type to be '${Helpers.nameof(this.rootConstructor)}', got '${Helpers.nameof(object.constructor)}'.`));\n            return undefined;\n        }\n\n        try\n        {\n            serializedObject = this.serializer.convertSingleValue(object, {\n                selfType: this.rootConstructor\n            });\n\n            return JSON.stringify(serializedObject, this.replacer, this.indent);\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n\n        return \"\";\n    }\n\n    public stringifyAsArray(object: T[], dimensions?: 1): string;\n    public stringifyAsArray(object: T[][], dimensions: 2): string;\n    public stringifyAsArray(object: T[][][], dimensions: 3): string;\n    public stringifyAsArray(object: T[][][][], dimensions: 4): string;\n    public stringifyAsArray(object: T[][][][][], dimensions: 5): string;\n    public stringifyAsArray(object: any[], dimensions: number = 1): string\n    {\n        let elementConstructorArray = new Array((dimensions - 1) || 0).fill(Array).concat(this.rootConstructor);\n\n        return JSON.stringify(this.serializer.convertAsArray(object, elementConstructorArray), this.replacer, this.indent);\n    }\n\n    public stringifyAsSet(object: Set<T>): string\n    {\n        return JSON.stringify(this.serializer.convertAsSet(object, this.rootConstructor), this.replacer, this.indent);\n    }\n\n    public stringifyAsMap<K>(object: Map<K, T>, keyConstructor: Constructor<K>): string\n    {\n        return JSON.stringify(this.serializer.convertAsMap(object, keyConstructor, this.rootConstructor), this.replacer, this.indent);\n    }\n\n    private _mapKnownTypes(constructors: Array<Constructor<any>>)\n    {\n        let map = new Map<string, Constructor<any>>();\n\n        constructors.filter(ctor => ctor).forEach(ctor => map.set(this.nameResolver(ctor), ctor));\n\n        return map;\n    }\n}\n\nexport { jsonObject } from \"./typedjson/json-object\";\nexport { jsonMember } from \"./typedjson/json-member\";\nexport { jsonArrayMember } from \"./typedjson/json-array-member\";\nexport { jsonSetMember } from \"./typedjson/json-set-member\";\nexport { jsonMapMember } from \"./typedjson/json-map-member\";\n"],"sourceRoot":""}