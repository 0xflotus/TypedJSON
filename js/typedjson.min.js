// [typedjson]  Version: 1.1.0-rc1 - 2018-05-07  
 !function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r():"function"==typeof define&&define.amd?define("typedjson",[],r):"object"==typeof exports?exports.typedjson=r():e.typedjson=r()}(window,function(){return function(e){var r={};function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},t.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=0)}([function(e,r,t){"use strict";t.r(r);const n="__typedJsonJsonObjectMetadataInformation__";function o(e){return"object"==typeof e}function s(e){if(o(e))return e;if(!o(e=JSON.parse(e)))throw new TypeError("TypedJSON can only parse JSON strings or plain JS objects");return e}function i(e,r){return e===r||e.prototype instanceof r}function a(e,...r){"object"==typeof console&&"function"==typeof console.error?console.error.apply(console,[e].concat(r)):"object"==typeof console&&"function"==typeof console.log&&console.log.apply(console,["ERROR: "+e].concat(r))}function c(e,...r){"object"==typeof console&&"function"==typeof console.warn?console.warn.apply(console,[e].concat(r)):"object"==typeof console&&"function"==typeof console.log&&console.log.apply(console,["WARNING: "+e].concat(r))}function l(e){return!(void 0===e||null===e)}function y(e,r){return"number"==typeof e?r===Number:"string"==typeof e?r===String:"boolean"==typeof e?r===Boolean:!!o(e)&&e instanceof r}const u="object"==typeof Reflect&&"function"==typeof Reflect.getMetadata;function p(...e){return e.join(" ")}function f(e){return"string"==typeof e.name?e.name:"undefined"}class d{}class h{constructor(){this.dataMembers=new Map,this.knownTypes=new Set}static getJsonObjectName(e){var r=this.getFromConstructor(e);return f(r?r.classType:e)}static getFromConstructor(e){var r,t;if(r="function"==typeof e?e.prototype:e)return r.hasOwnProperty(n)&&(t=r[n]),t&&t.isExplicitlyMarked?t:void 0}static getFromInstance(e){return this.getFromConstructor(Object.getPrototypeOf(e))}static getKnownTypeNameFromType(e){var r=this.getFromConstructor(e);return f(r?r.classType:e)}static getKnownTypeNameFromInstance(e){var r=this.getFromInstance(e);return f(r?r.classType:e.constructor)}}function m(e,r,t){var o,s,i=`@jsonMember on ${f(e.constructor)}.${r}`;"function"!=typeof e?"function"!=typeof e[r]?t&&(t.ctor||t.deserializer)?(e.hasOwnProperty(n)?o=e[n]:(o=new h,s=e[n],o.name=e.constructor.name,s&&s.dataMembers.forEach((e,r)=>o.dataMembers.set(r,e)),Object.defineProperty(e,n,{enumerable:!1,configurable:!1,writable:!1,value:o})),t.deserializer||o.knownTypes.add(t.ctor),t.keyType&&o.knownTypes.add(t.keyType),t.elementType&&t.elementType.forEach(e=>o.knownTypes.add(e)),o.dataMembers.set(t.name,t)):a(`${i}: JsonMemberMetadata has unknown ctor.`):a(`${i}: cannot use a method property.`):a(`${i}: cannot use a static property.`)}class T{constructor(){this._typeResolver=((e,r)=>{if(e.__type)return r.get(e.__type)}),this._errorHandler=(e=>a(e))}setNameResolver(e){this._nameResolver=e}setTypeResolver(e){if("function"!=typeof e)throw new TypeError("'typeResolverCallback' is not a function.");this._typeResolver=e}setErrorHandler(e){if("function"!=typeof e)throw new TypeError("'errorHandlerCallback' is not a function.");this._errorHandler=e}convertAsObject(e,r,t="object"){if("object"!=typeof e||null===e)return void this._errorHandler(new TypeError(`Cannot deserialize ${t}: 'sourceObject' must be a defined object.`));let n=r.selfConstructor,o=h.getFromConstructor(n),s=r.knownTypes;o&&(s=this._mergeKnownTypes(s,this._createKnownTypesMap(o.knownTypes)));let a=this._typeResolver(e,s);if(a&&i(a,n)&&(n=a,(o=h.getFromConstructor(a))&&(s=this._mergeKnownTypes(s,this._createKnownTypesMap(o.knownTypes)))),o&&o.isExplicitlyMarked){let r,i={};if(o.dataMembers.forEach((r,t)=>{let n,a=e[t],c=`${f(o.classType)}.${t}`,y=r.ctor;l(n=r.deserializer?r.deserializer(a):this.convertSingleValue(a,{selfConstructor:y,elementConstructor:r.elementType,keyConstructor:r.keyType,knownTypes:s},c))?i[r.key]=n:r.isRequired&&this._errorHandler(new TypeError(`Missing required member '${c}'.`))}),"function"==typeof o.initializerCallback)try{if(!(r=o.initializerCallback(i,e)))throw new TypeError(p(`Cannot deserialize ${t}:`,`'initializer' function returned undefined/null, but '${f(o.classType)}' was expected.`));if(!(r instanceof o.classType))throw new TypeError(p(`Cannot deserialize ${t}:`,`'initializer' returned '${f(r.constructor)}', but '${f(o.classType)}' was expected,`,`and '${f(r.constructor)}' is not a subtype of '${f(o.classType)}'`))}catch(e){return void this._errorHandler(e)}else r=this._instantiateType(n);return Object.assign(r,i),o.onDeserializedMethodName&&("function"==typeof r.constructor[o.onDeserializedMethodName]?r.constructor[o.onDeserializedMethodName]():this._errorHandler(new TypeError(`onDeserialized callback '${f(o.classType)}.${o.onDeserializedMethodName}' is not a method.`))),r}{let t={};return Object.keys(e).forEach(n=>{t[n]=this.convertSingleValue(e[n],{selfConstructor:e[n].constructor,knownTypes:r.knownTypes,elementConstructor:r.elementConstructor,keyConstructor:r.keyConstructor},n)}),t}}convertSingleValue(e,r,t="object"){let n=r.selfConstructor,o=e?f(e.constructor):"undefined";if(!l(e))return e;if(this._isDirectlyDeserializableNativeType(n)){if(e.constructor===n)return e;throw new TypeError(this._makeTypeErrorMessage(f(n),e.constructor,t))}if(n===Date){if("string"==typeof e||"number"==typeof e&&e>0)return new Date(e);this._throwTypeMismatchError("Date","an ISO-8601 string",o,t)}else if(n===Float32Array){if(e instanceof Array&&e.every(e=>!isNaN(e)))return new Float32Array(e);this._throwTypeMismatchError("Float32Array","a numeric source array",o,t)}else if(n===Float64Array){if(e instanceof Array&&e.every(e=>!isNaN(e)))return new Float64Array(e);this._throwTypeMismatchError("Float64Array","a numeric source array",o,t)}else if(n===Uint8Array){if(e instanceof Array&&e.every(e=>!isNaN(e)))return new Uint8Array(e.map(e=>~~e));this._throwTypeMismatchError("Uint8Array","a numeric source array",o,t)}else if(n===Uint8ClampedArray){if(e instanceof Array&&e.every(e=>!isNaN(e)))return new Uint8ClampedArray(e.map(e=>~~e));this._throwTypeMismatchError("Uint8ClampedArray","a numeric source array",o,t)}else if(n===Uint16Array){if(e instanceof Array&&e.every(e=>!isNaN(e)))return new Uint16Array(e.map(e=>~~e));this._throwTypeMismatchError("Uint16Array","a numeric source array",o,t)}else if(n===Uint32Array){if(e instanceof Array&&e.every(e=>!isNaN(e)))return new Uint32Array(e.map(e=>~~e));this._throwTypeMismatchError("Uint32Array","a numeric source array",o,t)}else if(n===ArrayBuffer){if("string"==typeof e)return this._stringToArrayBuffer(e);this._throwTypeMismatchError("ArrayBuffer","a string source",o,t)}else if(n===DataView){if("string"==typeof e)return this._stringToDataView(e);this._throwTypeMismatchError("DataView","a string source",o,t)}else{if(n===Array){if(e instanceof Array)return this.convertAsArray(e,r,t);throw new TypeError(this._makeTypeErrorMessage(Array,e.constructor,t))}if(n===Set){if(e instanceof Array)return this.convertAsSet(e,r,t);this._throwTypeMismatchError("Set","Array",o,t)}else if(n===Map){if(e instanceof Array)return this.convertAsMap(e,r,t);this._throwTypeMismatchError("Map","a source array of key-value-pair objects",o,t)}else if(e&&"object"==typeof e)return this.convertAsObject(e,r,t)}}convertAsArray(e,r,t="object"){if(!(e instanceof Array))return this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array,e.constructor,t))),[];if(!r.elementConstructor||!r.elementConstructor.length)return this._errorHandler(new TypeError(`Could not deserialize ${t} as Array: missing constructor reference of Array elements.`)),[];let n={selfConstructor:r.elementConstructor[0],elementConstructor:r.elementConstructor.length>1?r.elementConstructor.slice(1):[],knownTypes:r.knownTypes};return e.map(e=>{try{return this.convertSingleValue(e,n)}catch(e){return void this._errorHandler(e)}})}convertAsSet(e,r,t="object"){if(!(e instanceof Array))return this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array,e.constructor,t))),new Set;if(!r.elementConstructor||!r.elementConstructor.length)return this._errorHandler(new TypeError(`Could not deserialize ${t} as Set: missing constructor reference of Set elements.`)),new Set;let n={selfConstructor:r.elementConstructor[0],elementConstructor:r.elementConstructor.length>1?r.elementConstructor.slice(1):[],knownTypes:r.knownTypes},o=new Set;return e.forEach((e,r)=>{try{o.add(this.convertSingleValue(e,n,t+`[${r}]`))}catch(e){this._errorHandler(e)}}),o}convertAsMap(e,r,t="object"){if(e instanceof Array||this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array,e.constructor,t))),!r.keyConstructor)return this._errorHandler(new TypeError(`Could not deserialize ${t} as Map: missing key constructor.`)),new Map;if(!r.elementConstructor||!r.elementConstructor.length)return this._errorHandler(new TypeError(`Could not deserialize ${t} as Map: missing value constructor.`)),new Map;let n={selfConstructor:r.keyConstructor,knownTypes:r.knownTypes},o={selfConstructor:r.elementConstructor[0],elementConstructor:r.elementConstructor.length>1?r.elementConstructor.slice(1):[],knownTypes:r.knownTypes},s=new Map;return e.forEach(e=>{try{let r=this.convertSingleValue(e.key,n);l(r)&&s.set(r,this.convertSingleValue(e.value,o,t+`[${r}]`))}catch(e){this._errorHandler(e)}}),s}_throwTypeMismatchError(e,r,t,n="object"){throw new TypeError(`Could not deserialize ${n} as ${e}: expected ${r}, got ${t}.`)}_makeTypeErrorMessage(e,r,t="object"){return`Could not deserialize ${t}: expected '${"function"==typeof e?f(e):e}', got '${"function"==typeof r?f(r):r}'.`}_instantiateType(e){return new e}_mergeKnownTypes(...e){let r=new Map;return e.forEach(e=>{e.forEach((e,t)=>{this._nameResolver?r.set(this._nameResolver(e),e):r.set(t,e)})}),r}_createKnownTypesMap(e){let r=new Map;return e.forEach(e=>{this._nameResolver?r.set(this._nameResolver(e),e):r.set(e.name,e)}),r}_isDirectlyDeserializableNativeType(e){return~[Number,String,Boolean].indexOf(e)}convertNativeObject(e){return e}_stringToArrayBuffer(e){let r=new ArrayBuffer(2*e.length),t=new Uint16Array(r);for(let r=0,n=e.length;r<n;r++)t[r]=e.charCodeAt(r);return r}_stringToDataView(e){return new DataView(this._stringToArrayBuffer(e))}}class w{constructor(){this._typeHintEmitter=((e,r,t)=>{r.constructor!==t&&(e.__type=f(r.constructor))}),this._errorHandler=(e=>a(e))}setTypeHintEmitter(e){if("function"!=typeof e)throw new TypeError("'typeEmitterCallback' is not a function.");this._typeHintEmitter=e}setErrorHandler(e){if("function"!=typeof e)throw new TypeError("'errorHandlerCallback' is not a function.");this._errorHandler=e}convertSingleValue(e,r,t="object"){if(l(e)){if(y(e,r.selfType))return this._isDirectlySerializableNativeType(r.selfType)?e:r.selfType===ArrayBuffer?this.convertAsArrayBuffer(e):r.selfType===DataView?this.convertAsDataView(e):r.selfType===Array?this.convertAsArray(e,r.elementTypes,t):r.selfType===Set?this.convertAsSet(e,r.elementTypes[0],t):r.selfType===Map?this.convertAsMap(e,r.keyType,r.elementTypes[0],t):this._isTypeTypedArray(r.selfType)?this.convertAsTypedArray(e):"object"==typeof e?this.convertAsObject(e,r,t):void 0;{let n=f(r.selfType),o=f(e.constructor);this._errorHandler(new TypeError(`Could not serialize '${t}': expected '${n}', got '${o}'.`))}}}convertAsObject(e,r,t){let n,o;return(n=e.constructor!==r.selfType&&e instanceof r.selfType?h.getFromConstructor(e.constructor):h.getFromConstructor(r.selfType))?(o={},n.dataMembers.forEach((r,t)=>{r.serializer?o[r.name]=r.serializer(e[r.key]):o[r.name]=this.convertSingleValue(e[r.key],{selfType:r.ctor,elementTypes:r.elementType,keyType:r.keyType},`${f(n.classType)}.${r.key}`)})):o=Object.assign({},e),this._typeHintEmitter(o,e,r.selfType),o}convertAsArray(e,r,t="object"){if(0===r.length||!r[0])return void this._errorHandler(new TypeError(`Could not serialize ${t} as Array: missing element type definition.`));try{e.forEach((e,n)=>{if(!y(e,r[0])){let o=f(r[0]),s=f(e.constructor);throw new TypeError(`Could not serialize ${t}[${n}]: expected '${o}', got '${s}'.`)}})}catch(e){return void this._errorHandler(e)}let n={selfType:r[0],elementTypes:r.length>1?r.slice(1):[]};return t&&(t+="[]"),e.map(e=>this.convertSingleValue(e,n,t))}convertAsSet(e,r,t="object"){if(!r)return void this._errorHandler(new TypeError(`Could not serialize ${t} as Set: missing element type definition.`));let n={selfType:r};t&&(t+="[]");let o=[];return e.forEach(e=>{let r=this.convertSingleValue(e,n,t);l(e)&&!l(r)||o.push(r)}),o}convertAsMap(e,r,t,n="object"){if(!t)throw new TypeError(`Could not serialize ${n} as Map: missing value type definition.`);if(!r)throw new TypeError(`Could not serialize ${n} as Map: missing key type definition.`);let o={selfType:t,elementTypes:[t]},s={selfType:r};n&&(n+="[]");let i=[];return e.forEach((e,r)=>{let t={key:this.convertSingleValue(r,s,n),value:this.convertSingleValue(e,o,n)};l(t.key)&&l(t.value)&&i.push(t)}),i}convertAsTypedArray(e){return Array.from(e)}convertAsArrayBuffer(e){return Array.from(new Uint16Array(e)).map(e=>String.fromCharCode(e)).join("")}convertAsDataView(e){return this.convertAsArrayBuffer(e.buffer)}_isDirectlySerializableNativeType(e){return~[Date,Number,String,Boolean].indexOf(e)}_isTypeTypedArray(e){return~[Float32Array,Float64Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array].indexOf(e)}}function g(e){let r;r="function"==typeof e?{}:e||{};let t=function(e){let t,o;e.prototype.hasOwnProperty(n)?(t=e.prototype[n],r.name&&(t.name=r.name)):(t=new h,(o=e.prototype[n])&&(o.dataMembers.forEach((e,r)=>t.dataMembers.set(r,e)),o.knownTypes.forEach(e=>t.knownTypes.add(e))),r.name?t.name=r.name:t.name=e.name,Object.defineProperty(e.prototype,n,{enumerable:!1,configurable:!1,writable:!1,value:t})),t.classType=e,t.isExplicitlyMarked=!0,t.isAbstract=!1,t.initializerCallback=r.initializer,"string"==typeof r.knownTypes?t.knownTypeMethodName=r.knownTypes:r.knownTypes instanceof Array&&r.knownTypes.filter(e=>!!e).forEach(e=>t.knownTypes.add(e))};if("function"!=typeof e)return t;t(e)}function A(e,r){if(!(e instanceof Object)||"string"!=typeof r&&"symbol"!=typeof r)return(r,t)=>{let n,o=e||{},s=`@jsonMember on ${f(r.constructor)}.${t}`;if(o.hasOwnProperty("constructor")){if(!l(o.constructor))return void a(`${s}: cannot resolve specified property constructor at runtime.`);u&&!i(o.constructor,Reflect.getMetadata("design:type",r,t))&&c(`${s}: detected property type does not match 'constructor' option.`),n=o.constructor}else if(u){if(!(n=Reflect.getMetadata("design:type",r,t)))return void a(`${s}: cannot resolve detected property constructor at runtime.`)}else if(!o.deserializer)return void a(`${s}: ReflectDecorators is required if no 'constructor' option is specified.`);if(v(n,s))return;let y=new d;y.ctor=n,y.emitDefaultValue=o.emitDefaultValue||!1,y.isRequired=o.isRequired||!1,y.key=t.toString(),y.name=o.name||t.toString(),y.deserializer=o.deserializer,y.serializer=o.serializer,m(r,t,y)};{let t=e,n=`@jsonMember on ${f(t.constructor)}.${r}`;if(!u)return void a(`${n}: ReflectDecorators is required if no 'constructor' option is specified.`);{let e=Reflect.getMetadata("design:type",t,r),o=new d;if(!e)return void a(`${n}: could not resolve detected property constructor at runtime.`);if(v(e,n))return;o.ctor=e,o.key=r.toString(),o.name=r.toString(),m(t,r,o)}}}function v(e,r){return e===Array?(a(`${r}: property is an Array. Use the jsonArrayMember decorator to serialize this property.`),!0):e===Set?(a(`${r}: property is a Set. Use the jsonSetMember decorator to serialize this property.`),!0):e===Map&&(a(`${r}: property is a Map. Use the jsonMapMember decorator to serialize this property.`),!0)}function b(e,r={}){return(t,n)=>{let o=`@jsonArrayMember on ${f(t.constructor)}.${n}`;if("function"!=typeof e)return void a(`${o}: could not resolve constructor of array elements at runtime.`);if(!isNaN(r.dimensions)&&r.dimensions<1)return void a(`${o}: 'dimensions' option must be at least 1.`);if(u&&Reflect.getMetadata("design:type",t,n)!==Array)return void a(`${o}: property is not an Array.`);let s=new d;if(s.ctor=Array,r.dimensions&&r.dimensions>=1){s.elementType=[];for(let e=1;e<r.dimensions;e++)s.elementType.push(Array);s.elementType.push(e)}else s.elementType=[e];s.emitDefaultValue=r.emitDefaultValue||!1,s.isRequired=r.isRequired||!1,s.key=n.toString(),s.name=r.name||n.toString(),s.deserializer=r.deserializer,s.serializer=r.serializer,m(t,n,s)}}function C(e,r={}){return(t,n)=>{var o=`@jsonSetMember on ${f(t.constructor)}.${n}`;if("function"==typeof e)if(u&&Reflect.getMetadata("design:type",t,n)!==Set)a(`${o}: property is not a Set.`);else{var s=new d;s.ctor=Set,s.elementType=[e],s.emitDefaultValue=r.emitDefaultValue||!1,s.isRequired=r.isRequired||!1,s.key=n.toString(),s.name=r.name||n.toString(),s.deserializer=r.deserializer,s.serializer=r.serializer,m(t,n,s)}else a(`${o}: could not resolve constructor of set elements at runtime.`)}}function M(e,r,t={}){return(n,o)=>{let s=`@jsonMapMember on ${f(n.constructor)}.${o}`;if("function"!=typeof e)return void a(`${s}: could not resolve constructor of map keys at runtime.`);if("function"!=typeof r)return void a(`${s}: could not resolve constructor of map values at runtime.`);if(u&&Reflect.getMetadata("design:type",n,o)!==Map)return void a(`${s}: property is not a Map.`);let i=new d;i.ctor=Map,i.elementType=[r],i.keyType=e,i.emitDefaultValue=t.emitDefaultValue||!1,i.isRequired=t.isRequired||!1,i.key=o.toString(),i.name=t.name||o.toString(),i.deserializer=t.deserializer,i.serializer=t.serializer,m(n,o,i)}}t.d(r,"TypedJSON",function(){return _}),t.d(r,"jsonObject",function(){return g}),t.d(r,"jsonMember",function(){return A}),t.d(r,"jsonArrayMember",function(){return b}),t.d(r,"jsonSetMember",function(){return C}),t.d(r,"jsonMapMember",function(){return M});class _{constructor(e,r){this.serializer=new w,this.deserializer=new T,this.globalKnownTypes=[],this.indent=0;let t=h.getFromConstructor(e);if(!t||!t.isExplicitlyMarked)throw new TypeError("The TypedJSON root data type must have the @jsonObject decorator used.");this.nameResolver=(e=>f(e)),this.rootConstructor=e,this.errorHandler=(e=>a(e)),r?this.config(r):_._globalConfig&&this.config({})}static parse(e,r,t){const n=s(e);return new _(r,t).parse(n)}static parseAsArray(e,r,t){const n=s(e);return new _(r,t).parseAsArray(n)}static parseAsSet(e,r,t){const n=s(e);return new _(r,t).parseAsSet(n)}static parseAsMap(e,r,t,n){const o=s(e);return new _(t,n).parseAsMap(o,r)}static stringify(e,r,t){return new _(r,t).stringify(e)}static stringifyAsArray(e,r,t=1,n){return new _(r,n).stringifyAsArray(e,t)}static stringifyAsSet(e,r,t){return new _(r,t).stringifyAsSet(e)}static stringifyAsMap(e,r,t,n){return new _(t,n).stringifyAsMap(e,r)}static setGlobalConfig(e){this._globalConfig?Object.assign(this._globalConfig,e):this._globalConfig=e}config(e){_._globalConfig&&(e=Object.assign({},_._globalConfig,e)).knownTypes&&_._globalConfig.knownTypes&&(e.knownTypes=Array.from(new Set(e.knownTypes.concat(_._globalConfig.knownTypes)))),e.errorHandler&&(this.errorHandler=e.errorHandler,this.deserializer.setErrorHandler(e.errorHandler),this.serializer.setErrorHandler(e.errorHandler)),e.replacer&&(this.replacer=e.replacer),e.typeResolver&&this.deserializer.setTypeResolver(e.typeResolver),e.typeHintEmitter&&this.serializer.setTypeHintEmitter(e.typeHintEmitter),e.indent&&(this.indent=e.indent),e.nameResolver&&(this.nameResolver=e.nameResolver,this.deserializer.setNameResolver(e.nameResolver)),e.knownTypes&&(e.knownTypes.forEach((e,r)=>{void 0!==e&&null!==e||c(`TypedJSON.config: 'knownTypes' contains an undefined/null value (element ${r}).`)}),this.globalKnownTypes=e.knownTypes)}parse(e){let r,t=h.getFromConstructor(this.rootConstructor),n=new Map;this.globalKnownTypes.filter(e=>e).forEach(e=>{n.set(this.nameResolver(e),e)}),t&&t.knownTypes.forEach(e=>{n.set(this.nameResolver(e),e)});try{r=this.deserializer.convertSingleValue(e,{selfConstructor:this.rootConstructor,knownTypes:n})}catch(e){this.errorHandler(e)}return r}parseAsArray(e,r=1){return e instanceof Array?this.deserializer.convertAsArray(e,{selfConstructor:Array,elementConstructor:new Array(r-1||0).fill(Array).concat(this.rootConstructor),knownTypes:this._mapKnownTypes(this.globalKnownTypes)}):(this.errorHandler(new TypeError(`Expected 'json' to define an Array, but got ${typeof e}.`)),[])}parseAsSet(e){return e instanceof Array?this.deserializer.convertAsSet(e,{selfConstructor:Array,elementConstructor:[this.rootConstructor],knownTypes:this._mapKnownTypes(this.globalKnownTypes)}):(this.errorHandler(new TypeError(`Expected 'json' to define a Set (using an Array), but got ${typeof e}.`)),new Set)}parseAsMap(e,r){return e instanceof Array?this.deserializer.convertAsMap(e,{selfConstructor:Array,elementConstructor:[this.rootConstructor],knownTypes:this._mapKnownTypes(this.globalKnownTypes),keyConstructor:r}):(this.errorHandler(new TypeError(`Expected 'json' to define a Set (using an Array), but got ${typeof e}.`)),new Map)}stringify(e){let r;if(e instanceof this.rootConstructor){try{return r=this.serializer.convertSingleValue(e,{selfType:this.rootConstructor}),JSON.stringify(r,this.replacer,this.indent)}catch(e){this.errorHandler(e)}return""}this.errorHandler(TypeError(`Expected object type to be '${f(this.rootConstructor)}', got '${f(e.constructor)}'.`))}stringifyAsArray(e,r=1){let t=new Array(r-1||0).fill(Array).concat(this.rootConstructor);return JSON.stringify(this.serializer.convertAsArray(e,t),this.replacer,this.indent)}stringifyAsSet(e){return JSON.stringify(this.serializer.convertAsSet(e,this.rootConstructor),this.replacer,this.indent)}stringifyAsMap(e,r){return JSON.stringify(this.serializer.convertAsMap(e,r,this.rootConstructor),this.replacer,this.indent)}_mapKnownTypes(e){let r=new Map;return e.filter(e=>e).forEach(e=>r.set(this.nameResolver(e),e)),r}}}])});
//# sourceMappingURL=typedjson.min.js.map 